import React, { useState, useCallback, useLayoutEffect } from 'react';
import { Icon, Label } from 'semantic-ui-react';
import Tree from '../components/Tree';
import SearchBoxWithDropdown from '../components/SearchBoxWithDropdown';

// Tree structure from data
function Data(name) {
  this.name = name;
  this.markedInSearch = false;
}

function parse(name = 'App', input) {
  if (input) {
    const result = new Data(name);
    result.children = new Array(0);
    for (const el of Object.entries(input)) {
      // filter out keys starting with '$' and '__typename' generated by Apollo
      if (typeof el[1] === 'object') {
        if (!el[0].startsWith('$') && el[0] !== '__typename') {
          result.children.push(parse(el[0], el[1]));
        }
      } else if (!el[0].startsWith('$') && el[0] !== '__typename') {
        const newChild = new Data(el[0]);
        newChild.value = el[1];
        result.children.push(newChild);
      }
    }
    return result;
  }
  const emptyObject = new Data('root');
  return emptyObject;
}

const VisualizationContainer = props => {
  const { treeData } = props;
  const [fullTree, setFullTree] = useState(parse('root', treeData));
  const [newTree, setNewTree] = useState(null);
  const [searchKeyValue, setSearchKeyValue] = useState([]);
  const [input, setInput] = useState(null);
  const [filter, setFilter] = useState('key');
  const [isSearching, setIsSearching] = useState(false);

  // lifecycle hook
  useLayoutEffect(() => {
    // separating key searches
    if (searchKeyValue.length) {
      const inputKeys = searchKeyValue
        .filter(element => element[0] === 'key')
        .map(element => element[1])
        .join('|');
      // separating value searches
      const inputValues = searchKeyValue
        .filter(element => element[0] === 'value')
        .map(element => element[1])
        .join('|');
      setNewTree(markFound(fullTree, inputKeys, inputValues));
      setIsSearching(true);
    } else setIsSearching(false);
    // return handleClearSearch;
  }, [
    searchKeyValue.length,
    newTree,
    isSearching,
    searchKeyValue,
    markFound,
    fullTree,
  ]);

  useLayoutEffect(() => {
    setFullTree(parse('root', treeData));
  }, [treeData]);

  const handleOnChange = event => {
    const eventValue = event;
    eventValue.target.localName === 'input'
      ? setInput(eventValue.target.value)
      : setFilter(eventValue.target.innerText);
  };

  const handleOnClick = () => {
    const textBox = document.querySelector('#inputTextBox');
    setInput(textBox.value);
    if (textBox.value) {
      // deep clone and update state
      const tempSearchKeyValue = searchKeyValue.slice();
      tempSearchKeyValue.push([filter, input]);
      setSearchKeyValue(tempSearchKeyValue);
      textBox.value = '';
      textBox.focus();
    }
    // else handleClearSearch();
  };

  const handleKeyPress = event => {
    const eventValue = event;
    const { keyCode } = eventValue;
    if (keyCode === 13) handleOnClick();
    else setInput(eventValue.target.value);
  };

  const handleClearSearch = () => {
    if (!searchKeyValue.length) setIsSearching(false);
  };

  const handleRemoveKeyword = event => {
    const eventValue = event;
    const valueToRemove = eventValue.target.parentNode.innerText.split(' : ');
    for (let index = 0; index < searchKeyValue.length; index += 1) {
      if (
        valueToRemove[1] === searchKeyValue[index][1] &&
        valueToRemove[0] === searchKeyValue[index][0]
      ) {
        setSearchKeyValue(
          [].concat(
            searchKeyValue.slice(0, index),
            searchKeyValue.slice(index + 1, searchKeyValue.length)
          )
        );
      }
    }
    handleClearSearch();
  };

  const markFound = useCallback((tree, inputKeys, inputValues) => {
    if (inputKeys) {
      tree.markedInSearch = !!RegExp(`(${inputKeys})`, 'g').test(tree.name);
    }
    if (inputValues) {
      tree.markedInSearch = !!RegExp(`(${inputValues})`, 'g').test(tree.value);
    }
    if (tree.children) {
      for (const index in tree.children) {
        markFound(tree.children[index], inputKeys, inputValues);
      }
    }
    return tree;
  });

  return (
    <div style={{ padding: '10px' }}>
      <SearchBoxWithDropdown
        handleOnChange={handleOnChange}
        handleOnClick={handleOnClick}
        handleKeyPress={handleKeyPress}
        searchWord={input}
      />
      {isSearching
        ? searchKeyValue.map(element => {
            const [filter, keyword] = element;
            return (
              <Label as="a" color="pink" key={`label-${filter}-${keyword}`}>
                {`${filter} : ${keyword}`}
                <Icon
                  name="delete"
                  onClick={handleRemoveKeyword}
                  key={`icon-${filter}-${keyword}`}
                />
              </Label>
            );
          })
        : null}
      <Tree treeData={fullTree} isSearching={isSearching} />
    </div>
  );
};

export default VisualizationContainer;
